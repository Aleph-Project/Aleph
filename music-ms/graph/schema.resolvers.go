package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"

	"github.com/angel/music-ms/graph/generated"
	"github.com/angel/music-ms/graph/model"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// Songs is the resolver for the songs field.
func (r *queryResolver) Songs(ctx context.Context) ([]*model.Song, error) {
	songsData, err := r.Resolver.MusicService.GetSongs(ctx, 0, 0)
	if err != nil {
		return nil, err
	}

	var songs []*model.Song
	for _, s := range songsData {
		song := &model.Song{
			ID:          s.Song.ID.Hex(),
			Title:       s.Song.Title,
			Duration:    s.Song.Duration,
			SpotifyID:   strPtr(s.Song.SpotifyID),
			AlbumID:     strPtr(s.Song.AlbumID.Hex()),
			TrackNumber: &s.Song.TrackNumber,
			AudioURL:    strPtr(s.Song.AudioURL),
			CreatedAt:   strPtr(s.Song.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
			UpdatedAt:   strPtr(s.Song.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
			Album: &model.Album{
				ID:       s.Album.ID.Hex(),
				Title:    s.Album.Title,
				ImageURL: strPtr(s.Album.ImageURL),
				Artists:  []*model.Artist{}, // Los artistas se resolverán mediante el resolver de Album
				Songs:    []*model.Song{},   // Las canciones se resolverán mediante el resolver de Album
			},
		}

		// Agregar los artistas de la canción
		for _, artist := range s.Artists {
			song.Artists = append(song.Artists, &model.Artist{
				ID:         artist.ID.Hex(),
				Name:       artist.Name,
				SpotifyID:  strPtr(artist.SpotifyID),
				ImageURL:   strPtr(artist.ImageURL),
				Genres:     artist.Genres,
				Popularity: &artist.Popularity,
				CreatedAt:  strPtr(artist.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
				UpdatedAt:  strPtr(artist.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
			})
		}
		songs = append(songs, song)
	}
	return songs, nil
}

// Song is the resolver for the song field.
func (r *queryResolver) Song(ctx context.Context, id string) (*model.Song, error) {
	song, err := r.Resolver.MusicService.GetSong(ctx, id)
	if err != nil {
		return nil, err
	}
	albumID := song.Song.AlbumID.Hex()

	// Map Album
	album := &model.Album{
		ID:       song.Album.ID.Hex(),
		Title:    song.Album.Title,
		ImageURL: strPtr(song.Album.ImageURL),
		Artists:  []*model.Artist{}, // Los artistas se resuelven por separado si es necesario
		Songs:    []*model.Song{},   // Las canciones se resuelven por separado si es necesario
	}

	// Map Artists
	var artists []*model.Artist
	for _, artist := range song.Artists {
		artists = append(artists, &model.Artist{
			ID:         artist.ID.Hex(),
			Name:       artist.Name,
			SpotifyID:  strPtr(artist.SpotifyID),
			ImageURL:   strPtr(artist.ImageURL),
			Genres:     artist.Genres,
			Popularity: &artist.Popularity,
			CreatedAt:  strPtr(artist.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
			UpdatedAt:  strPtr(artist.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
		})
	}

	return &model.Song{
		ID:          song.Song.ID.Hex(),
		Title:       song.Song.Title,
		Duration:    song.Song.Duration,
		SpotifyID:   strPtr(song.Song.SpotifyID),
		AlbumID:     strPtr(albumID),
		TrackNumber: &song.Song.TrackNumber,
		AudioURL:    strPtr(song.Song.AudioURL),
		CreatedAt:   strPtr(song.Song.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
		UpdatedAt:   strPtr(song.Song.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
		Album:       album,
		Artists:     artists,
	}, nil
}

// Albums is the resolver for the albums field.
func (r *queryResolver) Albums(ctx context.Context) ([]*model.Album, error) {
	albumsData, err := r.Resolver.MusicService.GetAlbums(ctx)
	if err != nil {
		return nil, err
	}
	var albums []*model.Album
	for _, a := range albumsData {
		artistIDs := make([]string, len(a.ArtistIDs))
		for i, id := range a.ArtistIDs {
			artistIDs[i] = id.Hex()
		}
		albums = append(albums, &model.Album{
			ID:          a.ID.Hex(),
			Title:       a.Title,
			ReleaseDate: strPtr(a.ReleaseDate),
			SpotifyID:   strPtr(a.SpotifyID),
			Year:        &a.Year,
			CreatedAt:   strPtr(a.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
			UpdatedAt:   strPtr(a.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
			ArtistIds:   artistIDs,
			ImageURL:    strPtr(a.ImageURL),
		})
	}
	return albums, nil
}

// Album is the resolver for the album field.
func (r *queryResolver) Album(ctx context.Context, id string) (*model.Album, error) {
	album, err := r.Resolver.MusicService.GetAlbum(ctx, id)
	if err != nil {
		return nil, err
	}
	artistIDs := make([]string, len(album.ArtistIDs))
	for i, aid := range album.ArtistIDs {
		artistIDs[i] = aid.Hex()
	}

	// Obtener canciones del álbum
	var songs []*model.Song
	if album.Songs != nil {
		for _, s := range album.Songs {
			songs = append(songs, &model.Song{
				ID:          s.ID.Hex(),
				Title:       s.Title,
				Duration:    s.Duration,
				SpotifyID:   strPtr(s.SpotifyID),
				AlbumID:     strPtr(s.AlbumID.Hex()),
				TrackNumber: &s.TrackNumber,
				AudioURL:    strPtr(s.AudioURL),
				CreatedAt:   strPtr(s.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
				UpdatedAt:   strPtr(s.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
			})
		}
	}

	return &model.Album{
		ID:          album.ID.Hex(),
		Title:       album.Title,
		ReleaseDate: strPtr(album.ReleaseDate),
		SpotifyID:   strPtr(album.SpotifyID),
		Year:        &album.Year,
		CreatedAt:   strPtr(album.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
		UpdatedAt:   strPtr(album.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
		ArtistIds:   artistIDs,
		ImageURL:    strPtr(album.ImageURL),
		Songs:       songs, // <-- Agregado el listado de canciones
	}, nil
}

// Artists is the resolver for the artists field.
func (r *queryResolver) Artists(ctx context.Context) ([]*model.Artist, error) {
	artistsData, err := r.Resolver.MusicService.GetArtists(ctx, 0, 0) // 0,0 para sin paginación
	if err != nil {
		return nil, err
	}
	var artists []*model.Artist
	for _, a := range artistsData {
		artists = append(artists, &model.Artist{
			ID:         a.ID.Hex(),
			Name:       a.Name,
			SpotifyID:  strPtr(a.SpotifyID),
			ImageURL:   strPtr(a.ImageURL),
			Genres:     a.Genres,
			Popularity: &a.Popularity,
			CreatedAt:  strPtr(a.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
			UpdatedAt:  strPtr(a.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
		})
	}
	return artists, nil
}

// Artist is the resolver for the artist field.
func (r *queryResolver) Artist(ctx context.Context, id string) (*model.Artist, error) {
	artist, err := r.Resolver.MusicService.GetArtist(ctx, id)
	if err != nil {
		return nil, err
	}

	// Map albums
	var albums []*model.Album
	for _, a := range artist.Albums {
		artistIDs := make([]string, len(a.ArtistIDs))
		for i, aid := range a.ArtistIDs {
			artistIDs[i] = aid.Hex()
		}

		// Obtener detalles completos del álbum incluyendo canciones
		albumDetails, err := r.Resolver.MusicService.GetAlbum(ctx, a.ID.Hex())
		if err != nil {
			continue
		}

		// Mapear las canciones del álbum
		var albumSongs []*model.Song
		for _, s := range albumDetails.Songs {
			albumSongs = append(albumSongs, &model.Song{
				ID:          s.ID.Hex(),
				Title:       s.Title,
				Duration:    s.Duration,
				SpotifyID:   strPtr(s.SpotifyID),
				AlbumID:     strPtr(s.AlbumID.Hex()),
				TrackNumber: &s.TrackNumber,
				AudioURL:    strPtr(s.AudioURL),
				CreatedAt:   strPtr(s.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
				UpdatedAt:   strPtr(s.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
			})
		}

		albums = append(albums, &model.Album{
			ID:          a.ID.Hex(),
			Title:       a.Title,
			ReleaseDate: strPtr(a.ReleaseDate),
			SpotifyID:   strPtr(a.SpotifyID),
			Year:        &a.Year,
			CreatedAt:   strPtr(a.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
			UpdatedAt:   strPtr(a.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
			ArtistIds:   artistIDs,
			ImageURL:    strPtr(a.ImageURL),
			Songs:       albumSongs,
		})
	}

	// Map songs
	var songs []*model.Song
	for _, s := range artist.Songs {
		// Obtener información del álbum para cada canción
		var album *model.Album
		if s.AlbumID != primitive.NilObjectID {
			albumData, err := r.Resolver.MusicService.GetAlbum(ctx, s.AlbumID.Hex())
			if err == nil {
				album = &model.Album{
					ID:          albumData.ID.Hex(),
					Title:       albumData.Title,
					ReleaseDate: strPtr(albumData.ReleaseDate),
					SpotifyID:   strPtr(albumData.SpotifyID),
					Year:        &albumData.Year,
					CreatedAt:   strPtr(albumData.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
					UpdatedAt:   strPtr(albumData.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
					ImageURL:    strPtr(albumData.ImageURL),
				}
			}
		}

		songs = append(songs, &model.Song{
			ID:          s.ID.Hex(),
			Title:       s.Title,
			Duration:    s.Duration,
			SpotifyID:   strPtr(s.SpotifyID),
			AlbumID:     strPtr(s.AlbumID.Hex()),
			TrackNumber: &s.TrackNumber,
			AudioURL:    strPtr(s.AudioURL),
			CreatedAt:   strPtr(s.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
			UpdatedAt:   strPtr(s.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
			Album:       album,
		})
	}

	return &model.Artist{
		ID:         artist.ID.Hex(),
		Name:       artist.Name,
		SpotifyID:  strPtr(artist.SpotifyID),
		ImageURL:   strPtr(artist.ImageURL),
		Genres:     artist.Genres,
		Popularity: &artist.Popularity,
		CreatedAt:  strPtr(artist.CreatedAt.Format("2006-01-02T15:04:05Z07:00")),
		UpdatedAt:  strPtr(artist.UpdatedAt.Format("2006-01-02T15:04:05Z07:00")),
		Albums:     albums,
		Songs:      songs,
	}, nil
}

// Genres is the resolver for the genres field.
func (r *queryResolver) Genres(ctx context.Context) ([]*model.Genre, error) {
	genresData, err := r.Resolver.MusicService.GetGenres(ctx)
	if err != nil {
		return nil, err
	}
	var genres []*model.Genre
	for _, g := range genresData {
		id, _ := g["id"].(string)
		name, _ := g["name"].(string)
		slug, _ := g["slug"].(string)
		var count *int
		if v, ok := g["count"]; ok {
			switch val := v.(type) {
			case int:
				count = &val
			case int32:
				c := int(val)
				count = &c
			case int64:
				c := int(val)
				count = &c
			}
		}
		// Si falta algún campo requerido, ignora ese género
		if id == "" || name == "" || slug == "" {
			continue
		}
		genres = append(genres, &model.Genre{
			ID:    id,
			Name:  name,
			Slug:  slug,
			Count: count,
		})
	}
	return genres, nil
}

// Genre is the resolver for the genre field.
func (r *queryResolver) Genre(ctx context.Context, id string) (*model.Genre, error) {
	genreData, err := r.Resolver.MusicService.GetGenreByID(ctx, id)
	if err != nil {
		return nil, err
	}
	var count *int
	if v, ok := genreData["count"]; ok {
		c := int(v.(int32))
		count = &c
	}
	return &model.Genre{
		ID:    genreData["id"].(string),
		Name:  genreData["name"].(string),
		Slug:  genreData["slug"].(string),
		Count: count,
	}, nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*model.Category, error) {
	categoriesData, err := r.Resolver.MusicService.GetCategories(ctx)
	if err != nil {
		return nil, err
	}
	var categories []*model.Category
	for _, c := range categoriesData {
		var slug *string
		if c.Slug != "" {
			slug = &c.Slug
		}
		var imageURL *string
		if c.ImageURL != "" {
			imageURL = &c.ImageURL
		}
		categories = append(categories, &model.Category{
			ID:       c.ID.Hex(),
			Name:     c.Name,
			Slug:     slug,
			ImageURL: imageURL,
		})
	}
	return categories, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id string) (*model.Category, error) {
	categoriesData, err := r.Resolver.MusicService.GetCategories(ctx)
	if err != nil {
		return nil, err
	}
	for _, c := range categoriesData {
		if c.ID.Hex() == id {
			var slug *string
			if c.Slug != "" {
				slug = &c.Slug
			}
			var imageURL *string
			if c.ImageURL != "" {
				imageURL = &c.ImageURL
			}
			return &model.Category{
				ID:       c.ID.Hex(),
				Name:     c.Name,
				Slug:     slug,
				ImageURL: imageURL,
			}, nil
		}
	}
	return nil, fmt.Errorf("Category not found")
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
